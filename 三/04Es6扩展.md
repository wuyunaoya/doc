一:面向对象(oop思想)

面向对象:类  对象   属性  方法

面向对象：万事万物都可以看做是一个对象.

类别:人类       哺乳类      。。。。。在计算中把这样的类别叫做类.

在原来的javascript中面向对象:

let arr = Array();

这个Array()是类，这个类是没有任何实际功能，他只是一个容器，里面存储属性和方法。

真正拥有功能的是对象，对象是被这个类实例出来的，对象可以调用类里面定义的属性和方法。



(1):Es6中定义类:

class 类名{

}

类名:遵守命名规则，不能以数字开头，不能以关键字命名,多个单词使用驼峰命名规则,最好首字母大写.

(2):在类的内部定义属性

```js
 class Stu{
  //定义属性
   name;
   age;
 }
 let s = new Stu();
 //let arr = Array();
 s.name = "小明";

 //注意：在类的内部定义属性，在前面不能有任何的修饰符关键字.
```

(3):实现类内部的属性内容，那么要在类的外部，需要实例化类。使用new关键字实例.才能得到该类.

(4):在内的内部定义方法

```js
class Stu{
   //定义属性
   name;
   age;
   //定义方法
   getmag()
   {
    console.log("我在睡觉")
   }
 }
 let s = new Stu();
 //let arr = Array();
 s.name = "小明";
 console.log(s.name);
 s.getmag();
//注意定义方法时，前面不能有任何的修饰符关键字.
```



(5):使用constructor()关键字在类的内部定义构造函数,这个构造函数时被类实例化时创建出来。

当你实例化类的时候，这个类的内部构造方法自动调用，而且是优先去执行这个构造方法。



(6):静态属性和静态方法

​     成员属性和成员方法

​     是在内部定义的属性和方法我们叫做成员属性和成员方法。他们是属于对象的而不属于类的。



​     静态属性和静态方法

​     在类的内部使用static 关键修饰定义静态属性和静态的方法

​     static 属性名

​     static 方法名()

​    {

​    }

​    静态属性和静态方法是属于类的，不属于对象的.调用静态属性和静态的方法需要用类去实现.



(7):使用extends实现类的继承

​    子类一旦继承了父类，那么就拥有了父类的所有的属性和方法，包括构造方法在内.

​    子类的构造方法中要新增新的功能，那么必须先要去实现父类的构造方法.

​    使用super实现父类的构造方法.

​    子类重新定义了父类的方法，那么这个方法叫做覆盖。





二:es6扩展（字符串。数值。数组。对象。）

(1):字符串扩展

 str.includes（“字符”）判断该相邻的字符是否在这个字符串中存在   返回的是true/false

str.startsWith("字符")  判断该字符是否在这个字符串中已这个字符开头  返回的是true/false

str.endsWith("字符")  已字符串结尾  

strs.repeat(count)   让字符重复多少次

(2):数值扩展

Number.isInteger(数值)  判断这个数值是否是一个整数  (记忆)

Number.parseInt("数值字符串")  将字符串内容如果是数值开头，他会把数值解析出来。遇到字符串不做解析.

Math.trunc(数值)  去除小数点的内容



(3):数组扩展

Array.from()  将一个维数组转换为一个真数组

Array.of()  将里面内容，解析到数组中

arr.find()   判断满足条件的，返回第一个满足条件的内容元素.

arr.findIndex()  判断满足条件的，返回第一个满足条件的下标



(4):对象扩展

Object.is(值1，值2)  判断值是否完全相等，是判断他们存储的地址是否都是指向同一个地址.

Object.assign(目标对象,源对象)   将源对象数据拷贝到目标对象中



三:深拷贝 （面试题）

深拷贝原理:  赋值一个数据，赋值出来的内容进行修改，修改的内容不去影响原来的数据.那么这个就达到深拷贝.

值类型数据:

存储：值类型数据的值是直接存储在栈中

string       number    null    undefined    .... 

引用类型数据:

Array       Object     Function

存储:引用类型数据存储在推中的，栈中存储的变量.

值类型数据:

```js
 let n1 = 10;
 let n2 = n1;
 n2=30;
 console.log(n1);
```

引用类型:

```js
 let a = [3,4,5,6];
 let b = a;
 let c = a[0];
 b[2] = 2000;
 c=6000;
 console.log(a[2]);//2000
 console.log(a[0]);//3
```



深拷贝:

第一步:获取你拷贝的数据时值类类型数据还是引用类型的数据.

​           获取数据类型

第二步：获取的数据类型中，拷贝的数据分析是数组还是对象



第三步:如果是数组，那么定义容器 [ ] ,如果是对象，那么定义容器 {  }



第4步:将拿到数据，进行循环.放入到你定义对应容器中.



第五步：在做一次递归



总结:

​        理解面向对象思想  ，以及对象的定义.

​       深拷贝原理。和实现过程.

​       





 